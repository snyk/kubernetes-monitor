import { Writable } from 'stream';
import { chmodSync, writeFileSync, existsSync } from 'fs';
import { platform, tmpdir } from 'os';
import { resolve } from 'path';
import * as needle from 'needle';

import { throwIfEnvironmentVariableUnset } from './helpers';
import * as kubectl from '../../helpers/kubectl';
import { execWrapper as exec } from '../../helpers/exec';

const OPENSHIFT_CLI_VERSION = '4.7.0';

export async function validateRequiredEnvironment(): Promise<void> {
  console.log(
    'Checking for the required environment variables: OPENSHIFT4_USER, OPENSHIFT4_PASSWORD, OPENSHIFT4_CLUSTER_URL, DOCKER_HUB_RO_USERNAME, DOCKER_HUB_RO_PASSWORD',
  );
  throwIfEnvironmentVariableUnset('OPENSHIFT4_USER');
  throwIfEnvironmentVariableUnset('OPENSHIFT4_PASSWORD');
  throwIfEnvironmentVariableUnset('OPENSHIFT4_CLUSTER_URL');
  throwIfEnvironmentVariableUnset('DOCKER_HUB_RO_USERNAME');
  throwIfEnvironmentVariableUnset('DOCKER_HUB_RO_PASSWORD');
}

export async function setupTester(): Promise<void> {
  if (existsSync(resolve(process.cwd(), 'oc'))) {
    console.log('OpenShift CLI exists locally, skipping download');
    return;
  }

  const nodeJsPlatform = platform();
  const downloadUrl = getDownloadUrlForOpenShiftCli(
    nodeJsPlatform,
    OPENSHIFT_CLI_VERSION,
  );
  console.log('Downloading OpenShift CLI...');
  const response = await needle('get', downloadUrl);
  await extractOpenShiftCli(response.body);
  console.log('Downloaded OpenShift CLI!');
}

export async function returnUnchangedImageNameAndTag(
  imageNameAndTag: string,
): Promise<string> {
  // For OpenShift, the image name requires no pre-processing or loading into a cluster, hence we don't modify it.
  return imageNameAndTag;
}

export async function createCluster(): Promise<void> {
  throw new Error('Not implemented');
}

export async function deleteCluster(): Promise<void> {
  throw new Error('Not implemented');
}

export async function exportKubeConfig(): Promise<void> {
  const user = process.env['OPENSHIFT4_USER'];
  const userPassword = process.env['OPENSHIFT4_PASSWORD'];
  const clusterURL = process.env['OPENSHIFT4_CLUSTER_URL'];
  const tmp = tmpdir();
  const kubeconfigPath = `${tmp}/kubeconfig`;
  const cmd = // Local vs remote testing
    clusterURL === 'https://api.crc.testing:6443'
      ? // TODO(ivanstanev): pin to a specific CA certificate
        `./oc login -u "${user}" -p "${userPassword}" "${clusterURL}" --insecure-skip-tls-verify=true --kubeconfig ${kubeconfigPath}`
      : `./oc login --token="${userPassword}" --server="${clusterURL}" --kubeconfig ${kubeconfigPath}`;
  await exec(cmd);
  process.env.KUBECONFIG = kubeconfigPath;
}

async function tryDescribingResourceToFile(
  kind: string,
  name: string,
  namespace: string,
): Promise<void> {
  return kubectl
    .describeKubernetesResource(kind, name, namespace)
    .then((description) => {
      const fileName = `${kind}-${name}-${namespace}`;
      const filePath = process.env.CI
        ? // The directory is generated by CircleCI config (see .circleci/config.yml).
          `/tmp/logs/test/integration/openshift4/${fileName}`
        : `${tmpdir()}/${fileName}`;
      writeFileSync(filePath, description);
      console.log(`Description for ${kind} ${name} is stored in ${filePath}`);
    })
    .catch(() =>
      console.log(
        `Could not describe ${kind} ${name} in namespace ${namespace}`,
      ),
    );
}

export async function clean(): Promise<void> {
  await Promise.all([
    tryDescribingResourceToFile('deployment', 'snyk-operator', 'snyk-monitor'),
    tryDescribingResourceToFile('deployment', 'snyk-monitor', 'snyk-monitor'),
    tryDescribingResourceToFile(
      'catalogsource',
      'snyk-operator',
      'openshift-marketplace',
    ),
    tryDescribingResourceToFile(
      'subscription',
      'snyk-operator',
      'snyk-monitor',
    ),
  ]);

  // Kubernetes will be stuck trying to delete these resources if we don't clear the finalizers.
  await Promise.all([
    kubectl
      .patchResourceFinalizers(
        'customresourcedefinition',
        'snykmonitors.charts.helm.k8s.io',
        'snyk-monitor',
      )
      .catch(() => undefined),
    kubectl
      .patchResourceFinalizers(
        'snykmonitors.charts.helm.k8s.io',
        'snyk-monitor',
        'snyk-monitor',
      )
      .catch(() => undefined),
  ]);

  await Promise.all([
    kubectl
      .deleteResource(
        'customresourcedefinition',
        'snykmonitors.charts.helm.k8s.io',
        'default',
      )
      .catch(() => undefined),
    kubectl
      .deleteResource('catalogsource', 'snyk-operator', 'openshift-marketplace')
      .catch(() => undefined),
    kubectl
      .deleteResource('clusterrolebinding', 'snyk-monitor', 'default')
      .catch(() => undefined),
    kubectl
      .deleteResource('clusterrole', 'snyk-monitor', 'default')
      .catch(() => undefined),
    kubectl.deleteNamespace('services').catch(() => undefined),
    kubectl.deleteNamespace('snyk-monitor').catch(() => undefined),
  ]);
}

async function extractOpenShiftCli(fileStream: Writable): Promise<void> {
  const tmp = tmpdir();
  const temporaryTarLocation = `${tmp}/openshift-cli`;
  writeFileSync(temporaryTarLocation, fileStream);

  const currentLocation = process.cwd();
  await exec(`tar -C ${currentLocation} -xzvf ${temporaryTarLocation} oc`);

  const openShiftCliLocation = resolve(currentLocation, 'oc');
  chmodSync(openShiftCliLocation, 0o755); // rwxr-xr-x
}

function getDownloadUrlForOpenShiftCli(
  nodeJsPlatform: string,
  cliVersion: string,
): string {
  const normalisedPlatform =
    nodeJsPlatform === 'darwin' ? 'mac' : nodeJsPlatform;
  return `https://mirror.openshift.com/pub/openshift-v4/clients/ocp/${cliVersion}/openshift-client-${normalisedPlatform}-${cliVersion}.tar.gz`;
}
